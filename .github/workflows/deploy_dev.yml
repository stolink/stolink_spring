name: Deploy Development

on:
  push:
    branches: ["dev"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  packages: write
  contents: read

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: gradle

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew build -x test

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/stolink/stolink-spring
          tags: |
            type=raw,value=dev-latest
            type=sha,prefix=dev-

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_SSMFULL_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Deploy to EC2 via SSM
        env:
          POSTGRESQL_URL: ${{ secrets.POSTGRESQL_URL }}
          POSTGRESQL_USERNAME: ${{ secrets.POSTGRESQL_USERNAME }}
          POSTGRESQL_PASSWORD: ${{ secrets.POSTGRESQL_PASSWORD }}
          POSTGRESQL_PORT: ${{ vars.POSTGRESQL_PORT }}
          NEO4J_URI: ${{ secrets.NEO4J_URI }}
          NEO4J_USERNAME: ${{ secrets.NEO4J_USERNAME }}
          NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD }}
          NEO4J_PORT: ${{ vars.NEO4J_PORT }}
          RABBITMQ_IMAGE_HOST: ${{ secrets.RABBITMQ_IMAGE_HOST }}
          RABBITMQ_IMAGE_PORT: ${{ vars.RABBITMQ_IMAGE_PORT }}
          RABBITMQ_IMAGE_VHOST: ${{ vars.RABBITMQ_IMAGE_VHOST }}
          RABBITMQ_IMAGE_USER: ${{ secrets.RABBITMQ_IMAGE_USER }}
          RABBITMQ_IMAGE_PASSWORD: ${{ secrets.RABBITMQ_IMAGE_PASSWORD }}
          RABBITMQ_AGENT_HOST: ${{ secrets.RABBITMQ_AGENT_HOST }}
          RABBITMQ_AGENT_PORT: ${{ vars.RABBITMQ_AGENT_PORT }}
          RABBITMQ_AGENT_VHOST: ${{ vars.RABBITMQ_AGENT_VHOST }}
          RABBITMQ_AGENT_USER: ${{ secrets.RABBITMQ_AGENT_USER }}
          RABBITMQ_AGENT_PASSWORD: ${{ secrets.RABBITMQ_AGENT_PASSWORD }}
          ALB_DNS_NAME: ${{ secrets.ALB_DNS_NAME }}
          CLOUDFRONT_URL: ${{ vars.CLOUDFRONT_URL }}
          CLOUDFRONT_URL_DEV: ${{ vars.CLOUDFRONT_URL_DEV }}
          # OAuth2 & JWT
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_COOKIE_DOMAIN: ${{ vars.CLOUDFRONT_URL_DEV }}
          OAUTH2_REDIRECT_URI: ${{ vars.OAUTH2_REDIRECT_URI }}
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          # .env 파일 내용 생성
          ENV_CONTENT="POSTGRESQL_URL=${POSTGRESQL_URL}
          POSTGRESQL_USERNAME=${POSTGRESQL_USERNAME}
          POSTGRESQL_PASSWORD=${POSTGRESQL_PASSWORD}
          POSTGRESQL_PORT=${POSTGRESQL_PORT}
          NEO4J_URI=${NEO4J_URI}
          NEO4J_USERNAME=${NEO4J_USERNAME}
          NEO4J_PASSWORD=${NEO4J_PASSWORD}
          NEO4J_PORT=${NEO4J_PORT}
          RABBITMQ_IMAGE_HOST=${RABBITMQ_IMAGE_HOST}
          RABBITMQ_IMAGE_PORT=${RABBITMQ_IMAGE_PORT}
          RABBITMQ_IMAGE_VHOST=${RABBITMQ_IMAGE_VHOST}
          RABBITMQ_IMAGE_USER=${RABBITMQ_IMAGE_USER}
          RABBITMQ_IMAGE_PASSWORD=${RABBITMQ_IMAGE_PASSWORD}
          RABBITMQ_AGENT_HOST=${RABBITMQ_AGENT_HOST}
          RABBITMQ_AGENT_PORT=${RABBITMQ_AGENT_PORT}
          RABBITMQ_AGENT_VHOST=${RABBITMQ_AGENT_VHOST}
          RABBITMQ_AGENT_USER=${RABBITMQ_AGENT_USER}
          RABBITMQ_AGENT_PASSWORD=${RABBITMQ_AGENT_PASSWORD}
          APP_AI_CALLBACK_BASE_URL=http://${ALB_DNS_NAME}/api/internal/ai
          IMAGE_NAME=ghcr.io/stolink/stolink-spring:dev-latest
          CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173,http://localhost:5174,https://${CLOUDFRONT_URL},https://${CLOUDFRONT_URL_DEV}
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
          JWT_SECRET=${JWT_SECRET}
          JWT_COOKIE_DOMAIN=${JWT_COOKIE_DOMAIN}
          OAUTH2_REDIRECT_URI=${OAUTH2_REDIRECT_URI}
          SPRING_PROFILES_ACTIVE=dev"

          # Base64로 인코딩하여 SSM으로 전달 (특수문자 이스케이프 문제 해결)
          ENV_BASE64=$(echo "$ENV_CONTENT" | base64 -w 0)

          # SSM 명령 실행 및 Command ID 캡처
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:tag,Values=stolink-spring" \
            --parameters "commands=[
              \"sudo -i -u ubuntu bash -c 'mkdir -p /home/ubuntu/stolink-project'\",
              \"sudo -i -u ubuntu bash -c 'cd /home/ubuntu/stolink-project && if [ -d .git ]; then git fetch origin && git checkout dev && git pull origin dev; else git clone -b dev https://github.com/stolink/stolink_spring.git .; fi'\",
              \"sudo rm -f /home/ubuntu/stolink-project/.env && echo '${ENV_BASE64}' | base64 -d | sudo -u ubuntu tee /home/ubuntu/stolink-project/.env > /dev/null\",
              \"sudo -i -u ubuntu bash -c 'cd /home/ubuntu/stolink-project && echo ${GH_PAT} | sudo docker login ghcr.io -u stolink --password-stdin && sudo docker compose down --remove-orphans && sudo docker compose up -d --pull always && sudo docker image prune -f'\"
            ]" \
            --timeout-seconds 300 \
            --max-concurrency "50%" \
            --max-errors "0" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          # SSM 명령 완료 대기 (최대 5분)
          echo "Waiting for SSM command to complete..."
          for i in {1..30}; do
            STATUS=$(aws ssm list-commands --command-id "$COMMAND_ID" --query "Commands[0].Status" --output text)
            echo "Attempt $i/30: Status = $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "✅ SSM command completed successfully"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "❌ SSM command failed with status: $STATUS"
              # 실패 시 상세 로그 출력
              aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --query "CommandInvocations[0].CommandPlugins[0].Output" --output text
              exit 1
            fi

            sleep 10
          done

          if [ "$STATUS" != "Success" ]; then
            echo "❌ SSM command did not complete in time. Last status: $STATUS"
            exit 1
          fi

      - name: Health Check
        run: |
          echo "Waiting for application to start..."
          sleep 60

          HEALTH_URL="https://${{ vars.CLOUDFRONT_URL_DEV }}/actuator/health"
          echo "Health check URL: $HEALTH_URL"

          for i in {1..5}; do
            echo "Health check attempt $i/5..."
            HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" --max-time 10 "$HEALTH_URL" 2>&1)
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "✅ Health check passed!"
              cat /tmp/health_response.txt
              exit 0
            fi
            
            echo "❌ Attempt $i failed with HTTP code: $HTTP_CODE"
            echo "Response body:"
            cat /tmp/health_response.txt 2>/dev/null || echo "(no response body)"
            echo ""
            echo "Retrying in 10 seconds..."
            sleep 10
          done

          echo "❌ Health check failed after 5 attempts"
          echo "Last HTTP code: $HTTP_CODE"
          exit 1
