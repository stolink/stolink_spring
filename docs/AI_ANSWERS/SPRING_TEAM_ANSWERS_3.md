# Spring 팀 질문에 대한 답변 (Answers to Request #3)

> **작성일**: 2026-01-02  
> **주제**: pgvector 마이그레이션 정책 및 캐릭터 병합 전략  

---

## 1. Regarding pgvector

### Q: 기존 데이터 마이그레이션 (재계산 vs NULL)
**A: 데이터 차원에 따라 다릅니다.**
- 만약 기존 데이터가 이미 **1024차원 배열**(Titan V2)로 저장되어 있다면, SQL Casting (`dataset::vector(1024)`)으로 완벽하게 마이그레이션 가능합니다.
- 만약 **데이터가 없거나(NULL), 차원이 다르다면(예: 1536차원 OpenAI)**:
  - **단기**: NULL 처리 후, 백그라운드 배치로 임베딩을 다시 생성해야 합니다.
  - **권장**: 현재 개발 초기 단계이므로, 문제가 되는 데이터는 초기화(Truncate)하거나 NULL로 두고, AI 쪽에서 재분석 요청을 보내 새로 채우는 것이 가장 깔끔합니다.

### Q: `hibernate-vector` 라이브러리 제약사항
**A: 제약사항 없음, 적극 권장합니다.**
- AI팀은 DB에 직접 접근하지 않고 Spring이 관리하는 테이블을 읽기만 하거나(또는 Callback으로 데이터 전달), 벡터 유사도 검색 쿼리 자체는 Spring에서 수행할 것이므로 Spring 생태계 표준 라이브러리를 사용하시는 것이 가장 좋습니다.
- **주의**: Docker Compose의 Postgres 이미지 버전과 `hibernate-vector`가 요구하는 pgvector 확장 버전 호환성만 체크해 주시면 됩니다.

---

## 2. Regarding Global Merge Strategy

### Q: Option A (Hard Merge) 기반 프로퍼티 충돌 정책
**A: AI 팀은 "Hard Merge" 방식에 동의하며, 다음과 같은 구체적인 충돌 해결 정책을 제안합니다.**

병합 대상: `Node A` (유지, Main) + `Node B` (삭제, Merged)

1.  **단일 값 필드 (이름, 나이, 성별 등)**
    - 원칙: **신뢰도(Intelligence)가 높은 쪽** 또는 **최신 분석 결과**를 우선합니다.
    - 실제 구현 단순화: `A`의 데이터를 유지하되, `A`가 NULL인 경우에만 `B`의 값을 가져갑니다 (`Coalesce`).

2.  **리스트/집합 필드 (성격, 별칭, 키워드)**
    - 원칙: **합집합 (Union)** 처리하되 중복 제거.
    - 예: `A.aliases=["이안"]`, `B.aliases=["Ian"]` -> `Merged.aliases=["이안", "Ian"]`

3.  **긴 텍스트 (설명, 백스토리)**
    - 정책: **"더 긴 텍스트"**를 유지하거나, 여유가 된다면 `[A 내용] + \n + [B 내용]`으로 합칩니다. (단순 합치기가 정보 유실이 적음)

4.  **관계 (Relationships)**
    - `B`에 연결된 모든 엣지를 `A`로 리다이렉트(`apoc.refactor.mergeNodes` 사용 시 자동 처리됨)

---

## 3. Regarding Semantic Chunking

**A: 확인했습니다.**
- 더미 데이터 생성 시나리오를 활용해 주시면 감사하겠습니다.
- 특히 **"장소 이동"**, **"시간 경과(다음 날 아침)"**, **"화자 전환(시점이동)"** 등의 요소가 포함된 텍스트라면 테스트에 매우 효과적입니다.

---
추가적인 논의가 필요하면 언제든 말씀해 주세요.
